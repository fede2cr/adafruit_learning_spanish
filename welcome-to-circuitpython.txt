Salve este archivo. Nada sucede con la tarjeta. Vamos a revisar la consola serial para ver que está pasando.
Tenemos un ImportError . Dice que no tenemos un módulo de nombre ‘simpleio’. ¡Este es el que acabamos de agregar en nuestro código!


Dá click en el enlace arriba para descargar el agrupado correcto. Extrae la carpeta lib del archivo descargado con el agrupado. Baja hasta ver el simpleio.mpy. ¡Este es el archivo de librería que andamos buscando! Sigue los pasos descritos arriba para cargar un archivo de librería de forma individual.

¡Ahora el LED comienza a parpadear de nuevo! Vamos a revisar la consola serial.

¡Sin errores! Excelente. ¡Has resuelto correctamente un error de ImportError !

Si te topas con este error en el futuro, sigue los pasos descritos arriba y escoja la librería que te hace falta.

Instalación de librerías en tarjetas que no son Express

Si tienes una Trinket M0 o una Gemma M0, vas a querer seguir los mismos pasos en el ejemplo anterior para instalar librerías mientras van haciendo falta. No siempre debes esperar a recibir el error ImportError dado que probablemente sabes que librería vas a necesitar ya que sabes que librería has agregado a tu código. Simplemente abre la carpeta lib que descargaste, escoge la librería que necesitas y arrástrala a la carpeta lib de tu unidad de disco CIRCUITPY.

Es posible que te quedes sin espacio en tu Trinket M0 o Gemma M0 incluso si vas copiando las librerías mientras las necesitas.

Hay una serie de pasos que se pueden realizar para resolver este problema. Las vas a encontrar en la página de Depuración de la Guía de Aprendizaje para tu tarjeta.

Actualizando Librerías o Ejemplos de CircuitPython

Las librerías y sus ejemplos se actualizan de forma constante, y es importante actualizar los archivos que tienes en tu unidad de disco CIRCUITPY.

Para actualizar las librerías de forma individual, sigue los mismos pasos descritos arriba. Cuando arrastras un archivo de librería a tu carpeta lib, te va a preguntar si la deseas reemplazar. Dile que sí. ¡Eso es todo!

Una nueva versión del agrupado de librerías es liberado cuando existe una actualización a una librería. Las actualizaciones incluyen cosas como arreglos a pulgas y nuevas características. Es importante revisar de vez en cuando para ver si las librerías que utilizas han sido actualizadas.

¡Bienvenido a la Comunidad!

CircuitPython es un lenguaje de programación al cual es super sencillo para iniciar y excelente para aprendizaje. Corre en microcontroladoras y funciona saliendo de la caja. Lo puedes conectar y comenzar a trabajar con cualquier editor de texto. ¿La mejor parte?

CircuitPython incluye una sorprendente comunidad que nos apoya.

¡Todos son bienvenidos! CircuitPython es Código Abierto. Esto significa que está disponible para todos para usar, editar, copiar y mejorar. Esto también significa que CircuitPython mejora porque tu eres una parte de él. No importa si es tu primer tarjeta microcontroladora o si eres un ingeniero informático, tu tienes algo importante que aportar a la Comunidad CircuitPython. ¡Vamos a subrayar algunos aspectos en los que te puedes involucrar!

Discord de Adafruit

El servidor de Discord de Adafruit es el mejor lugar para inciar. Discord es donde la comunidad de congrega para voluntariado y dar ayuda en vivo de todo tipo. Desde discusión en general hasta como resolver detalladamente un problema y cualquier cosa en medio, Discord es un maker space digital con makers de todo el mundo. 

Existen muchos canales diferentes así que puedes escoger el que mejor se adapte a tus necesidades. Cada canal es mostrado en Discord como “#nombrecanal”. Existe el canal #projecthelp para asistencia con proyectos en progreso, o para buscar ayudas para el siguiente proyecto. Existe el canal #showandtell para mostrar tus últimas creaciones. ¡No tengas miedo de preguntar en ningún canal! Si estás incierto, el canal #general es un excelente lugar comenzar. Si hay otro canal que sea más apropiado para darte una mejor respuesta, alguien te va a guiar hacia él.

El canal CircuitPython es donde puedes ir para realizar preguntas sobre CircuitPython. #circuitpython está ahí tanto para usuarios novatos como también para desarrolladores, así que ¡siéntete en libertad de realizar preguntas o enviar comentarios!

Todos con cualquier nivel de experiencia son bienvenidos a participar en la conversación. ¡Nos encantaría escuchar lo que tienes que decir! La mejor manera para contribuir con la comunidad es ayudar a otros en Discord.
Ayudar a otros no siempre quiere decir responder sus preguntas. ¡Participa celebrando cuando algo sale bien! ¡Celebra tus errores! Algunas veces solo escuchar que alguien más ha tenido problemas en un área similar que por lo que uno está pasando puede ser suficiente para ayudarle a un maker a avanzar.

El Discord de Adafruit es un hackerspace abierto las 24x7, todos los días del año y adonde también puedes traer a tu hija Visita https://adafru.it/discord () para crear una cuenta para Discord. ¡Estamos ansiosos por conocerte!

Foros de Adafruit

Los Foros de Adafruit (https://adafru.it/jIf) son el lugar perfecto para solicitar asistencia técnica. Adafruit tiene varios maravillosas personas a las que paga para dar asistencia técnica y responder cualquier pregunta que puedas tener. Ya sea que tu hardware te está dando problemas o que tu código parece no funcionar, los foros siempre están ahí para tus consultas. Usted necesita una cuenta de Adafruit para escribir a los foros. Usted puede utilizar la misma cuenta para realizar pedidos de Adafruit.

Mientras puede que en Discord encuentres una respuesta más rápida que en los foros, los foros son una fuente más confiable de información. Si quieres estar seguro de recibir una respuesta respaldada por Adafruit, los foros son el mejor lugar para ello. Las categorías de los foros cubren todo tipo de temas, incluyendo todo lo relacionado con Adafruit. La categoría de Adafruit CircuitPython y MicroPython (https://adafru.it/xXA) bajo "Supported Products & Projects" (o Productos y Proyectos con Asistencia Técnia) es el mejor lugar para enviar tus preguntas sobre CircuitPython.

Asegúrate de incluir todos los pasos que tomaste para llegar a donde te encuentras. Si involucra cableado, ¡envía una fotografía! Si tu código está teniendo problemas, ¡incluye tu código en la consulta! Estas son buenas prácticas para asegurarnos que vamos a tener suficiente información para ayudar con tu consulta.

Pueda que creas que apenas estáns comenzando, pero definitivamente sabes algo que alguien más no. ¡Lo bueno de los foros es que tu también puedes ayudar a otros! Todos son bienvenidos is alentados a dar retroalimentación constructiva a las consultas enviadas. ¡Es una excelente forma para contribuir a la comunidad y compartir tus conocimientos!

GitHub de Adafruit

Ya sea que estés comenzando o que seas programador de toda la vida que te gustaría contribuir, hay formas para que todos sean parte de construir CircuitPython. GitHub es la mejor de las formas para contribuir a CircuitPython (https://adafru.it/tB7). Si necesitas una cuenta, visita https://github.com/ (https://adafru.it/d6C) y solicita la tuya.

Si eres nuevo hacia GitHub o programación en general, hay buenas oportunidades para ti. Visita adafruit/circuitpython (https://adafru.it/tB7) en GitHub, dá click en "Issues (https://adafru.it/Bee)", y vas a encontrar una lista de problemas que han sido clasificados como "good first issue (https://adafru.it/Bef)" (o buen primer problema). Estas son cosas que hemos identificado como algo en lo que cualquier con cualquier nivel de experiencia puede contribuir. Estos temas pueden incluir opciones como actualizar documentación, dar retroalimentación o arreglando pulgas sencillas.

¿Ya tienes experiencia y buscas un reto? Revisa el resto de problemas y vas a encontrar suficientes formas en las que puedes contribuir. Vas a encontrar de todo desde solicitudes para nuevas controladoras a actualización de módulos del núcleo. ¡Hay muchas oportunidades para todos los niveles!

Cuando se trabaja con CircuitPython, se pueden encontrar problemas. Si encuentras una pulga, ¡es excelente! ¡Nos encantan las pulgas! Enviar un reporte de problema detallado a GitHub es una manera invaluable para contribuir en la mejora de CircuitPython. Asegúrate de incluir los pasos relevantes para replicar el problema, así como cualquier otra información que te parezca relevante. Entre más detalle, ¡mejor!

Probar nuevo software es algo sencillo y de mucha ayuda. Simplemente cargue la nueva versión de CircuitPython o una librería en tu hardware para CircuitPython, y úsalo. Déjanos saber de cualquier problema que puedas encontrar, escribiendo un “issue” en GitHub.

Probar software tanto en la versión estable como en las beta es una parte muy importante de contribuir a CircuitPython. ¡Nosotros no podemos encontrar todos los problemas! Necesitamos tu ayuda haciendo CircuitPython todavía mejor.

En GitHub, puedes enviar solicitud de características, dar retroalimentación, reportar problemas y mucho más. Si tienes consultas, ¡recuerda que Discord y los Foros están para ayudar!

ReadTheDocs
ReadTheDocs (https://adafru.it/Beg) es un excelente recurso para una mirada más profunda a CircuitPython. Aquí es donde vas a encontrar cosas como documentación del API y detalles sobre los módulos del núcleo. También hay Guías de Diseño que incluyen guías sobre como contribuir a CircuitPython.

RTD nos da un acceso a bajo nivel de CircuitPython. Hay detalles sobre cada uno de los módulos núcleo (https://adafru.it/Beh). Cada módulo lista las librerías disponibles. Cada página de módulo de librería lista los parámetros disponibles y la explicación de cada uno. En muchos casos, vas a encontrar ejemplos rápidos de código que te van a ayudar a entender como funcionan los módulos y sus parámetros, sin embargo no va a tener explicaciones detalladas como las Guías de Aprendizaje. Si quieres ayuda aprendiendo que sucede detrás del telón en el código de CircuitPython que escribes, ¡ReadTheDocs está para ayudar!

Consola Serial Avanzada para Windows
Controlador para Windows 7

Si estás utilizando Windows 7, usa el enlace abajo para descargar el paquete con el controlador. No vas a tener que instalar controladores ni para Mac, Linux o Windows 10.

https://adafru.it/AB0

¿Que es el COM?

Primero, quieres saber cual de los puertos seriales es el que usa tu tarjeta. Cuando conectas tu tarjeta por USB a tu computadora, se conecta a un puerto serial. Este puerto es un acceso por el cual tu tarjeta se comunica con tu computadora utilizando USB.

Nosotros vamos a utiliza el Administrador de Dispositivos de Windows para determinar cual puerto de la tarjeta estás utilizando. La forma más sencilla para determinar cual puerto está utilizando la tarjeta es primero revisar la lista de puertos sin haber conectado la tarjeta. Abra el Administrador de Dispositivos. De click a Puertos (COM y LPT). Deberías encontrar algo en esta lista con un nombre como COM# donde # es un número.

Ahora conecta tu tarjeta. La lista del Administrador de Dispositivos se va a refrescar y va a aparecer un puerto nuevo bajo Puertos (COM & LPT).

Vas a encontrar un nuevo (COM#) en esta lista.

Algunas veces el puerto se va a referir al nombre de la tarjeta. Otras veces puede que se llame algo como USB Serial Device, como se observa en la imagen arriba. De cualquier forma, aparece un nuevo (COM#) seguido por el nombre.

Este es el puerto de la tarjeta que estás utilizando.

Instalando Putty

Si estás utilizando Windows, vas a tener que descargar una aplicación terminal. Vamos a utilizar PuTTY.

Lo primero que debes hacer es descargar la última versión de PuTTY (https://adafru.it/Bf1). Vas a querer descargar el archivo instalador para Windows. Lo más probable es que vas a necesitar la versión de 64-bits. Descargar el archivo e instalar la aplicación en tu computadora. Si tienes problemas, puedes tratar descargando más bien la versión de 32-bits. Sin embargo, la versión de 64-bits va a funicionar en la mayoría de computadoras personales.

Ahora va a querer abrir PuTTY.

Bajo Connection type: busca el botón a la par de Serial.

En la caja bajo la línea de Serial, digita el puerto serial que encontraste que utiliza tu tarjeta.

En la caja bajo Speed, digita 115200. Esto se llama la taza de baudios, que es la velocidad en bits por segundo que los datos se transfieren por la conexión serial. Para tarjetas con USB integrado no importa mucho, pero para tarjetas como las ESP8266 y otras con un chip adicional, la velocidad requerida por la placa es 115200 bits por segundo. ¡Así que porqué no usar 115200!

Si deseas guardar estos parámetros, utiliza las opciones bajo para cargar, salvar o borrar una sesión almacenada. Digita el nombre de la sesión en la caja bajo Saved Sessions, y dá click en el botón Save a la derecha.

Una vez que los parámetros se han digitado, estás listo para conectarte a la consola serial. Dá click a “Open” en la parte de abajo de la ventana. Una nueva ventana se abrirá.

Si no hay código en ejecución, la ventana va a verse en blanco o se va a ver como la ventana arriba. Ahora estás listo para ver los resultados de tu código.

¡Buen trabajo! ¡Te has conectado a la consola serial!

Conexión Serial Avanzada para Mac y Linux

Conectándose a la consola serial de Mac y Linux es esencialmente el mismo proceso. Ninguno de los dos sistemas operativos necesita que se instalen controladores. En MacOSX, la aplicación Terminal viene instalada. En Linux hay una variedad como gnome-terminal (llamada Terminal) o Konsole bajo KDE.

¿Cual es el puerto?

Primero vas a querer averiguar cual es el puerto serial que utiliza tu tarjeta. Cuando conectas tu tarjeta por USB a tu computadora, se conecta a un puerto serial. El puerto es un acceso por el cual tu tarjeta se comunica con tu computadora utilizando USB.

Vamos a utilizar Terminal para determinar cual puerto está usando la tarjeta. La forma más sencilla para determinar cual puerto está utilizando la tarjeta es primero revisar sin haber conectado la tarjeta. En Mac, abre Terminal, y escribe lo siguiente:

ls /dev/tty.*

Cada conexión serial aparece en la carpeta /dev/ . Tiene un nombre que comienza con tty. . El comando ls muestra una lista del contenido de la carpeta. Puede utilizar * como un metacaracter, para buscar archivos que comienzan su nombre con las mismas letras, pero terminan en algo diferente. En este caso, te pedimos que veas todo lo listado que comience con tty. y termine en cualquier cosa. Esto nos va a mostrar las conexiones seriales presentes.  

Para Linux, el procedimiento es el mismo, sin embargo, el nombre es ligeramente diferente. Si está utilizando Linux, vas a escribir:

ls /dev/ttyACM*

El conepto es el mismo con Linux. Te pedimos que veas lo listado de la carpeta /dev, comenzando con ttyACM y terminando en cualquier cosa. Esto va a mostrar las conexiones seriales presentes. En el ejemplo anterior el error es indicando que no hay conexiones seriales presentes que comiencen con ttyACM .

Ahora conecta tu tarjeta. Utilizando Mac, escribe:

ls /dev/tty.*

Esto va a mostrar las conexiones seriales presentes, en las cuales se incluye la de tu tarjeta.

Utilizando Mac, un nuevo puerto aparece con el nombre /dev/tty.usbmodem141441 . La parte tty.usbmodem141441 es en este ejemplo el nombre de la tarjeta que estás usando. La tuya va a tener un nombre similar.

Utilizando Linux, escribe:

ls /dev/ttyACM*

Esto va a mostrar las conexiones seriales presentes, en las cuales se incluye la de tu tarjeta.

Utilizando Linux, un nuevo puerto aparece con el nombre /dev/ttyACM0 . La parte ttyACM0 en este ejemplo es el nombre de la tarjeta que estás utilizando. La tuya va a tener un nombre similar.

Conectándose con screen

Ahora que conoces el nombre de la tarjeta que estás utilizando, estás listo para conectarte a la consola serial. Vamos a utilizar un comando llamado screen. El comando screen se incluye con MacOS. Los usuarios de Linux es posible que lo vayan a tener que instalar utilizando su administrador de paquetes. Para conectarse a la consola serial, utilice Terminal. Escriba el siguiente comando, reemplazando nombre_tarjeta por el nombre que encontraste que usa tu tarjeta:

screen /dev/tty.nombre_tarjeta 115200

La primera porción de este comando establece que vas a utilizar el comando screen. La segunda parte le dice a screen el nombre de la tarjeta que estás tratando de usar. La tercera parte le indica a screen la taza de baudios a utilizar para la conexión serial. La taza de baudios es la velocidad en bits por segundo en que se transfieren datos por la conexión serial. En este caso la velocidad requerida por la tarjeta es 115200 bits por segundo.

Digita enter para ejecutar el comando. Se abre en la misma ventana. Si ningún código está corriendo, la ventana se va a ver en blanco.

De otra forma, vas a ver la salida de tu código.

¡Buen trabajo! ¡Te has conectado a la consola serial!

Permisos en Linux

Si tratas de conectarte con screen y no funciona, es posible que tengas un problema con los permisos. Linux le da seguimiendo a los usuarios y grupos y lo que pueden hacer y no hacer, como acceso al hardware asociado con la consola serial para correr screen . Así que si ves algo como esto:

es posible que necesites darte acceso. Existen básicamente dos formas para lograrlo. La primera es ejecutar screen con el comando de sudo, el cual temporalmente entrega privilegios elevados. Una vez que escribas tu contraseña, ya debería funcionar:

La segunda forma es agregándote al grupo asociado con el hardware. Para averiguar cual grupo es el correcto, utiliza el comando ls -l como se muestra abajo. El nombre del grupo está marcado en un círculo rojo.

Ahora utiliza el comando adduser para agregar a tu usuario al grupo. Necesitas permisos elevados para realizar esto, por lo cual necesitas utilizar sudo . En el ejemplo abajo, el grupo es adm y el usuario ackbar.

Luego de que te agregues al grupo, necesitas deslogearte y logearte de nuevo, o en algunos casos, reiniciar tu computadora. Luego de que te logees de nuevo, verifica que te has agregado utilizando el comando groups . Si no estás en el grupo, reinicia y revisa de nuevo.
Ahora debes poderte conectar con screen sin necesidad de sudo .

Y ya estás adentro:

Los ejemplos de arriba utilizan screen , pero si lo prefieres puede utilizar otros programas como putty o picocom.

PyCharm y CircuitPython

ESTE PROCESO NO FUNCIONA. Este plugin nunca fue diseñado para trabajar con CircuitPython. El proceso descrito es una forma de lograrla con funcionalidad limitada. SI DESEA UTILIZAR REPL CON PYCHARM, UTILICE LA TERMINAL INTEGRADA Y screen.


PyCharm (https://adafru.it/xNC) es un editor con todas las características incluyendo cosas super útiles como completado de código y señalado de errores. Está disponible gratis en su versión comunitaria.

Recientemente, agregaron un plugin para MicroPython (https://adafru.it/Bex) el cual habilita el uso del REPL desde el editor.

CircuitPython no está bajo mantenimiento oficial, sin embargo ¡tenemos algunos pasos para lograr que funcione!

Descarge (https://adafru.it/Bey) e instale PyCharm en su computadora. Ahora, ¡conecte la tarjeta y siga los pasos descritos arriba!

Cree un nuevo proyecto o abra un proyecto existente.

Abra PyCharm y luego Preferences/Settings. Dé click en Plugins y busque “micropython”. Dé click en Search para buscar en los repositorios.

ESTE PROCESO NO FUNCIONA. Este plugin nunca fue diseñado para trabajar con CircuitPython. El proceso descrito es una forma de lograrla con funcionalidad limitada. SI DESEA UTILIZAR REPL CON PYCHARM, UTILICE LA TERMINAL INTEGRADA Y screen.

Dé click en Install.

Una vez que el proceso completa, de click en Restart PyCharm.

Una vez reiniciado, abra Preferences/Settings. Dé click en Languages & Frameworks y escoja MicroPython.

ESTE PROCESO NO FUNCIONA. Este plugin nunca fue diseñado para trabajar con CircuitPython. El proceso descrito es una forma de lograrla con funcionalidad limitada. SI DESEA UTILIZAR REPL CON PYCHARM, UTILICE LA TERMINAL INTEGRADA Y screen.

Escoja su carpeta de directorio de la lista.

Escoja ESP8266 de la lista de Device Names (o Nombres de Dispositivos).

Por ahora, vas a utilizar esta opción sin importar la tarjeta que utilices.

Vas a necesitar agregar manualmente la ruta del dispositivo o Device Path.
Esta es la ruta hacia tu conexión serial. Una vez escrita, dé click en Ok.

Si necesitas ayuda encontrando la consola serial de tu dispositivo visita la sección Advanced Serial Console on
Windows (https://adafru.it/AAH) y Advanced Serial
Console on Mac and Linux (https://adafru.it/AAI).

ESTE PROCESO NO FUNCIONA. Este plugin nunca fue diseñado para trabajar con CircuitPython. El proceso descrito es una forma de lograrla con funcionalidad limitada. SI DESEA UTILIZAR REPL CON PYCHARM, UTILICE LA TERMINAL INTEGRADA Y screen.

Ahora, abra cualquier archivo de Python de la carpeta de proyecto que has seleccionado.

Puede que aparezca un mensaje diciendo "Packages required for
ESP8266 support not found", seguidos de una lista de paquetes. Haga click en Install Requirements en este mensaje para instalar los paquetes requeridos.
Ahora le puedes dar click al menú de Tools (o Herramientas) y vas a poder encontrar un menú MicroPython. Señala esto, y vas a encontrar el REPL para MicroPython disponible.


El REPL se abrirá en la parte inferior de la ventana de PyCharm. ¡Ya puedes comenzar a programar!

Si deseas utilizar el REPL con una tarjeta diferente, vas a tener que ir a modificar la ruta del dispositivo a la ruta apropiada para la tarjeta que deseas utilizar.

Para cambiar la ruta de dispositivo, siga los pasos descritos arriba, comenzando por agregar manualmente la ruta de dispositivo.

El REPL de PyCharm no va a trabajar con múltiples tarjetas al mismo tiempo. Seguir los pasos descritos arriba para múltiples proyectos no resulta para abrir múltiples conexiones a REPL de forma simultánea.

Las funcionalidades de "Remove All Files from MicroPython Device" y "Flash Project"  no funcionan, pero podrían corromper tu tarjeta. No trates de utilizar estas funcionalidades. Recuerda, CircuitPython no está bajo mantenimiento oficial, y estos son solo algunos pasos para lograr que funcione.

ESTE PROCESO NO FUNCIONA. Este plugin nunca fue diseñado para trabajar con CircuitPython. El proceso descrito es una forma de lograrla con funcionalidad limitada. SI DESEA UTILIZAR REPL CON PYCHARM, UTILICE LA TERMINAL INTEGRADA Y screen.

CircuitPython para ESP8266

Nosotros ya no estamos dando mantenimiento a CircuitPython en ESP8266. Esta página es solamente por razones históricas. No hay garantía que las instrucciones continúen funcionando.

¿Porqué no damos mantenimiento a las ESP8266?

Correr CircuitPython en las ESP8266 no ha sido una buena experiencia para los usuario. Es difícil enviar archivos al dispositivo porque no tiene USB nativo, y rápidamente te puedes quedar sin memoria RAM (queda menos de lo que crees una vez que activas los componentes para redes). Hemos decidido utilizar las ESP solo como un co-procesador. Específicamente la ESP32 porque tiene muy buenas capacidades de TLS/SSL las cuales son esenciales para las interacciones más básicas.

Si desea utilizar ESP8266, favor mantenga la versión 3.x teniendo en mente que no le damos mantenimiento. ¡También puede usar MicroPython para ESP8266 a la cual le dan mantenimiento!

Si deseas agregar capacidades de WiFi, revisa nuestra guía sobre usar las ESP32/ESP8266 como un co-procesador. (https://adafru.it/Dwa)

Sobre ESP8266 para CircuitPython (3.x)

Tenemos dos sub-versiones de CircuitPython, la primaria es para tarjetas basadas en ATSAMD21/51 que tienen conectividad nativa por USB. USB nativo significa que la tarjeta aparece como una unidad de disco llamada CIRCUITPY donde puedes almacenar tus archivos.

También hay CircuitPython para tarjetas como las ESP8266 y nRF52832, estos son muy buenos chips con WiFi y Bluetooth integrados, respectivamente. ¡Pero no tienen soporte nativo para USB! Esto significa que no hay forma que el chip aparezca como una unidad de disco. Usted todavía las puede usar con CircuitPython pero es mucho más difícil, así que no las recomendamos para principiantes.

Esto es lo que debes saber si utilizas chips no-nativos a CircuitPython:

¡Solo tienes una conexión al REPL! No hay capacidades de teclado y mouse HID u otras interfaces USB. No hay unidades de disco para arrastrar archivos, y los archivos deben ser manipulados con una herramienta como ampy la cual “escribe” tu archivo usando el REPL.

Cargando CircuitPython requiere herramientas de línea de comandos

Instalando CircuitPython en una ESP8266

Para utilizar CircuitPython con una ESP8266 primero necesitas cargarlo con el último firmware.

Descargue esptool

Primero instale la herramienta esptool.py que permite subirle firmware a una ESP8266. La forma más sencilla para instalar esta herramienta es con el administrador de paquetes para Python llamado pip . Si aún no lo tiene, debe instalar Python 2.7 (https://adafru.it/fa7) (asegúrese de marcar la caja para poner Python en tu sistema cuando instalas Windows) y luego ejecute el siguiente comando en una terminal: pip install esptool

Tome nota que en Mac OSX y Linux puede que necesite ejecutar el comando en conjunto con sudo, de esta manera: sudo pip install esptool

Si recibes un error de que esptoo.py solo trabaja con Python 2.x, trata de ejecutarlo de nuevo pero con pip2 en lugar de pip (lo más probable es que tu sistema esté usando Python 3 y el comando pip se confunde con cual usar).

Descargue la última versión del firmware de CircuitPython

Ahora, descargue el archivo de la última versión del firmware de CircuitPython para ESP8266:

https://adafru.it/F9z

Alistando la ESP8266 para booteo

Ahora necesitas poner a la ESP8266 en modo de subido de firmware. En cada ESP8266 es un poco diferente:

Para un módulo ESP8266 puro, necesitas cablear botones hacia tierra para los pines de GPIO0 y RESET. Presionas el botón de GPIO0 (o conectas la línea a tierra) y mientras lo mantienes presionado, presiona y suelta el botón RESET (o conectas y desconectas la línea a tierra), y luego sueltas GPIO0.

Para las HUZZAH ESP8266 breakout (https://adafru.it/f9X) tiene botones de GPIO0 y RESET integrados en la tarjeta. Presiona GPIO0, luego presiona y suelta RESET (manteniendo presionado GPIO0) y luego suelta GPIO0.

Para la ESP8266 HUZZAH en formato Feather (https://adafru.it/n6A) no necesitas hacer nada especial para activar el modo de subido de firmware. Esta tarjeta está construida para detectar cuando el puerto serial está abierto para subida y automáticamente configura el módulo de la ESP8266 para recibir el firmware. ¡Asegúrate de instalar el controlador para los SiLabs CP210x (https://adafru.it/jCs) en Windows y en Mac OSX para permitir que se vea el puerto de la tarjeta! En Windows quieres el controlador normal VCP, y no el controlador con enumeración serial ('with Serial Enumeration').

Borrar la ESP8266

Es recomendable eliminar la memoria de flash completa de la tarjeta ESP8266 antes de subirle firmware. Ejecute el siguiente comando en una terminal para ejecutar este borrado:

esptool.py --port NOMBREPUERTO_ESP8266 erase_flash

donde NOMBREPUERTO_ESP8266 es la ruta o el nombre del puerto serial que está conectado a la ESP8266. El nombre exacto varía dependiendo del tipo de convertidor serial así que vas a querer revisar la lista de puertos seriales con y sin la tarjeta conectada para encontrar su nombre.


Programar la ESP8266

Ahora, activa de nuevo el modo de subido de firmware en la ESP8266 y ejecuta el siguiente comando para cargarle el archivo de firmware:

esptool.py --port NOMBREPUERTO_ESP8266 --baud 115200 write_flash --flash_size=detect 0 firmware.bin

De nuevo, NOMBREPUERTO_ESP8266 es la ruta o nombre del puerto serial que está conectado a la ESP8266. Así mismo, defina el nombre o ruta del archivo de firmware que desea cargar.

Una vez que la herramienta termina de subir el firmware (normalmente vas a ver una luz azul en el módulo ESP8266 durante el proceso de subida) presiona el botón RESET en la tarjeta ESP8266 o desconéctala y reconéctala a tu computadora. ¡Ya deberías estar listo para usar el firmware de CircuitPython en la tarjeta!

Toma nota que si observas un error de "detect is not a valid flash_size parameter" (o no es capaz de detectar el tamaño del flash) puede que tengas una versión vieja de esptool.py. Para actualizar a la última versión ejecuta el siguiente comando:
pip install --upgrade esptool

¡Suba librerías y archivos usando Ampy!

La diferencia más grande que vas a ver con las ESP8266 es que necesitas una herramienta especial para manipular archivos. Aprende de ampy leyendo esta guía. ¡Es sobre MicroPython, pero para CircuitPython el proceso de instalación y de uso es básicamente idéntico!

https://adafru.it/q9C

¡Otras cosas para tomar en cuenta!

El REPL funciona como se esperaría, así que revisa la página de introducción.

El almacenamiento de archivos en el chip es compartido con el de CircuitPython, ¡por lo cual si actualizas es posible que pierdas los archivos! Utiliza respaldos.

Las librerías y API son los mismos para otras tarjetas para CircuitPython.
Toma nota que la ESP8266 no tiene muchos pines disponibles y solo una entrada analógica en el rango de 0.1-0V. No hay puerto de UART disponible (¡porque es usado por el REPL!).
No hay salidas analógicas.

¡Puedes usar SPI e I2C! Pero necesitas utilizar bitbangio (https://adafru.it/zcx) para crear el bus de objetos.

Desinstalando CircuitPython

Muchas de nuestras tarjetas se pueden utilizar con múltiples lenguajes de programación. Por ejemplo la Circuit Playground Express puede ser usada con MakeCode, Code.org CS Discoveries, CircuitPython y Arduino.

¿Puede que hayas probado CircuitPython y ahora quieres regresar a MakeCode o Arduino? No es problema. ¡Siempre puedes remover y reinstalar CircuitPython cuando lo desees! ¡Incluso puedes cambiar de parecer todos los días!

Respalda tu Código

Antes de desinstalar CircuitPython, no te olvides de realizar un respaldo del código que tienes en la pequeña unidad de disco. Eso significa main.py o code.py y otros archivos, la carpeta lib, etc. Es posible que pierdas estos archivos cuando remueves CircuitPython, ¡por lo que los respaldos son clave! Solo arrastra los archivos a una carpeta en tu laptop o computadora de escritorio, como lo harías con cualquier otra memoria USB.

Pasándose la Circuit Playground Express a MakeCode

En la Circuit Playground Express (por el momento esto NO aplica para la Circuit Playground Bluefruit), si deseas devolverte a usar MakeCode, es realmente sencillo. Visita makecode.adafruit.com (https://adafru.it/wpC) y encuentra el programa que deseas subir. Da click en Download para descargar el archivo .uf2 que genera Makecode.

Ahora da doble click en el botón de reset de tu tarjeta CircuitPython hasta que veas las luces LED prender en verte y luego que aparezca el directorio ...BOOT .

Ahora encuentra el archivo .uf2 descargado de MakeCode y arrástralo a la unidad de disco ...BOOT.

Tu código MakeCode ahora se está ejecutando y CircuitPython ha sido eliminado. De ahora en adelante solo debes dar un solo click al botón de reset.

Paśandose a Arduino

Si quieres mover tu firmware hacia Arduino, es muy sencillo.

Comienza por conectar tu tarjeta y dándole doble click al botón de reset hasta que recibas las luces LED integradas de color verde – igual que con MakeCode.

Dentro del IDE de Arduno, selecciona la tarjeta correcta, diciéndole que use la Circuit Playground Express, y seleccionando el puerto correspondiente:

Crear un nuevo programa ejemplo para Parpadear:

// la función setup se ejecuta cuando presionas reset o prendes la tarjeta
void setup() {
// inicialice el pin 13 para salida.
pinMode(13, OUTPUT);
}
// la función de loop se repite una y otra vez
void loop() {
digitalWrite(13, HIGH);
// prenda el LED (HIGH o alto, es el nivel de voltaje)
delay(1000);
// espere un segundo
digitalWrite(13, LOW);
// apaga el LED pasando el voltaje a LOW (bajo)
delay(1000);
// espere un segundo
}

Asegúrate que los LEDs todavía están de color verde, da click en Upload para subir el código de parpadeo. Una vez que ha subido correctamente el puerto serial va a cambiar, ¡así que seleccione el nuevo puerto!

Una vez que el código de parpadeo ha sido subido, no es necesario volver a dar doble click en el botón de reset para entrar en modo de booteo, Arduino va a resetear la tarjeta de forma automática cuando subes nuevo firmware.


Instalación sin UF2

¡Esta página de instalación es solo necesaria si no tienes un gestor de arranque UF2 instalado (donde sale ...BOOT y le arrastramos archivos)! Esta página es para tarjeta no-Express como Feather M0, Arduino Zero y M0 y otras tarjetas a la medida con chips ATSAMD21.

Subiendo con Bossac – Para las Feather M0 no-Express y Arduino Zero

Nuestras tarjetas viejas de formato Feather con chips M0 no vienen con UF2, sino con un gestor de arranque más sencillo llamado bossa. Esto es lo que está instalado en los Arduino Zero y otras tarjetas para CircuitPython que usan chips como ATSAMDx1 o nRF52840. Es el único método de instalación que puedes utilizar si el archivo de instalación de CircuitPython es de tipo .bin en lugar de un .uf2 .

¡Vamos a la línea de comando!

Para subir firmware con bossac requiere utilizar la línea de comando de tu computadora. En Windows, se llama cmd o herramienta powershell. ¡En mac o Linux, usar Terminal!

Descarga el último firmware CircuitPython

Lo primero que vas a querer hacer es descargar la última versión de CircuitPython. Desde Abril del 2019, existen dos páginas web para descargar el archivo .bin apropiado. Adafruit está migrando sus archivos hacia CircuitPython.org (https://adafru.it/Em8). Se sugiere que busques el archivo .bin compatible para tu tarjeta primero ahí, buscando la tarjeta. Solo tarjetas compatibles que han recibido modificaciones específicas para definir sus pines apropiados van a ser listados en el sitio, por lo cual los desarrolladores deberían enviar sus material (por medio de un pull request) si tienen una tarjeta con CircuitPython la cual desean que salga listada.

Da click al botón verde abajo para buscar tu tarjeta y encontrar el archivo apropiado.

https://adafru.it/Em8

De forma alternativa, use GitHub

Por ahora, los archivos de tarjetas para CircuitPython también están disponibles en el repositorio de CircuitPython de Adafruit, aunque a futuro se desea mover a un repositorio separado. Si tienes problemas con CircuitPython.org, trata de descargarlo de GitHub utilizando este segundo botón verde.

https://adafru.it/vlF

Una vez descargado, salvar el archivo .bin en tu equipo de escritorio, ¡ya casi lo vas a ocupar!

Si estás usando Windows 7, debes instalar el controlador (hablamos de ello, en esta página) (https://adafru.it/Bfd) para tener acceso al puerto COM.


Descargando BOSSA

Una vez que tienes el archivo con el firmware, vas a necesitar descargar la herramienta BOSSA, la cual puede cargarle firmware a tarjetas con chips SAMD21/51. Esta herramienta es usada internamente por el IDE de Arduino cuando programa estas tarjetas, sin embargo lo puedes usar para subir tu firmware a la medida.

¡Ten cuidado que necesitas una versión 1.7.0 o superior de bossac para programar tarjetas con chips SAMD21 y SAMD51! Versionas de BOSSA anteriores a 1.7.0 no van a funcionar porque no saben hablar con chips SAMD21/51. También tener cuidado que versiones 1.9.0 o más nuevas pueden tener un problema de incompatibilidad al cambiar sus parámetros de línea de comando y puede eliminar tu gestor de arranque si no está protegido (Las tarjetas de Adafruit se envían con gestores de arranque protegidos). Sigue las instrucciones a continuación con mucho cuidado, dependiendo de que versión tengas.

Para subir firmware con bossac (la herramienta de línea de comando de BOSSA) primero descar la última versión de aquí (https://adafru.it/Bfe).

La versión ming32 es para Windows, la versión apple-darwin para Mac OSX y varios opciones de Linux para Linux.

Bossac solo trabaja con archivos .bin, ¡no funciona con archivos .uf2!

Pruebe bossac

Abra una terminal y navegue por la carpeta con la herramienta bossac. Ahora revise que la aplicación funciona, probando con la opción --help con bossac --help


Si estás utilizando Linux o Mac OSX, vas a necesitar agregar un ./ para decirle que ejecute bossac desde el directorio actual, así ./bossac --help

¡Asegúrate de que observes BOSSA versión 1.7.0 o superior! Y nota la observación abajo sobre la versión 1.9.0 o superior. Si ves una versión anterior es porque descargaste por error una versión anterior y no va a funcionar para subirle a chips SAMD21. Regresa y descarga la última versión del repositorio de GitHub de BOSSA (https://adafru.it/s1B) como se mencionó arriba.

Selección de puerto para Mac OS

Vas a necesitar saber que puerto usar si estás en Mac.

En la misma terminal, ejecuta el comando ls /dev/cu.* . Nota los puertos listados, ahora conecta tu tarjeta y ejecuta el comando de nuevo. El dispositivo listado puede llamarse algo similar a /dev/cu.usbmodem14301. Toma nota del nombre del puerto para usarlo en la sección que sigue.

Entra en el gestor de arranque

Vas a tener que darle un empujón a la tarjeta para que entre en modo de gestor de arranque. Lo haces dándole doble-click al botón de reset en la tarjeta. El LED rojo “#13” va a parpadear. Si estás usando un Arduino Zero, asegúrate de que estás conectado al puerto USB nativo y no al puerto de depuración/programación.

Una nota importante, si estás utilizando un Arduino M0 de Arduino.org, vas a necesitar reemplazar su gestor de arranque con el gestor de arranque de Arduino Zero para que pueda trabajar con BOSSA. Para esto, instala las tarjetas Arduino/Genuino Zero en el IDE de Arduino y luego sigue estos pasos para subir el gestor de arranque (https://adafru.it/s1D) (usando el puerto de programación en la tarjeta). Una vez que has agregado el gestor de arranque de las Arduino Zero, vas a poder utilizar la M0 con bossac como se describe abajo.


Ejecutando el comando bossac

Con tu tarjeta conectada y corriendo el gestor de arranque, estás listo para subirle el firmware de CircuitPython a la tarjeta.

Copia el archivo .bin con el firmware al mismo directorio donde reside la herramienta bossac, y luego en una terminal entre en la misma carpeta y ejecute los siguiente comandos, dependiendo de la versión de bossac que tengas.

Con bossac versiones 1.9 o superiores debes usar el parámetro --offset en la línea de comando, y debe tener el valor correcto para tu tarjeta.

Con bossac versiones 1.9 o superior, le debes indicar en el pámetro --offset donde debe comenzar a escribir el firmware en la memoria flash. Este parámetro se agregó desde bossac 1.8.0 por omisión en 0x2000, pero en 1.9 por omisión se definió a 0x0000 , lo cual no es deseable en la mayoría de casos. Si omites el argumento a bossac 1.9 o superior, probablemente vas  a recibir un error de “Verify Failed” o verificación fallida.

Recuerda cambiar la opción -p o --port para usar el mismo puerto que en tu Mac.

Reemplaza el nombre abajo por el archivo que has descargado de tipo .bin , teniendo en cuenta que ¡varía dependiendo de tu tarjeta!

Utilizando bossac versiones 1.7.0, 1.8

No existe el parámetro --offset. Utiliza el comando de la siguiente forma:

bossac -p /dev/cu.usbmodem14301 -e -w -v -R adafruit-circuitpython-
nombretarjeta-version.bin

Por ejemplo,

bossac -p /dev/cu.usbmodem14301 -e -w -v -R adafruit-circuitpython-feather_m0_express-3.0.0.bin

Usando bossac para versiones 1.9 y superiores

Para tarjetas M0, las cuales tienen 8kB para el gestor de arranque, debes especificar --offset=0x2000 , por ejemplo:
bossac -p /dev/cu.usbmodem14301 -e -w -v -R --offset=0x2000 adafruit-circuitpython-feather_m0_express-3.0.0.bin

Para tarjetas M4, las cuales tienen 16kB para el gestor de arranque, debes especificar --offset=0x4000 , por ejemplo:

bossac -p /dev/cu.usbmodem14301 -e -w -v -R --offset=0x4000 adafruit-circuitpython-feather_m4_express-3.0.0.bin

Esto va a (e) borrar la memoria en el chip, (w) escribir el archivo indicado, (v) verifiaar la escritura y (R) reinicia la tarjeta. En Linux o MacOS vas a querer ejecutar el comando con sudo ./bossac ... , o agregarte primero al grupo de dialout.

Luego de que BOSSA carga el firmware vas a ver una salida similar a la siguiente:


Puedes reiniciar manualmente la tarjeta dando click al botón de reset, que algunas veces es necesario para despertar la tarjeta. Las tarjetas Express es posible que muestre una advertencia de haber expulsado incorrectamente una unidad de disco USB, la cual se puede ignorar sin problemas. ¡Nada importante se estaba escribiendo a la unidad de disco!


Depuración
De vez en cuando, 

From time to time, you will run into issues when working with CircuitPython. Here are a few things you may encounter
and how to resolve them.
As we continue to develop CircuitPython and create new releases, we will stop supporting older releases.
Visit https://circuitpython.org/downloads to download the latest version of CircuitPython for your board. You
must download the CircuitPython Library Bundle that matches your version of CircuitPython. Please update
CircuitPython and then visit https://circuitpython.org/libraries to download the latest Library Bundle.
Always Run the Latest Version of CircuitPython and Libraries
As we continue to develop CircuitPython and create new releases, we will stop supporting older releases. You need to
update to the latest CircuitPython. (https://adafru.it/Em8).
You need to download the CircuitPython Library Bundle that matches your version of CircuitPython. Please update
CircuitPython and then download the latest bundle (https://adafru.it/ENC).
As we release new versions of CircuitPython, we will stop providing the previous bundles as automatically created
downloads on the Adafruit CircuitPython Library Bundle repo. If you must continue to use an earlier version, you can
still download the appropriate version of mpy-cross from the particular release of CircuitPython on the CircuitPython
repo and create your own compatible .mpy library files. However, it is best to update to the latest for both
CircuitPython and the library bundle.
I have to continue using CircuitPython 3.x or 2.x, where can I find compatible
libraries?
We are no longer building or supporting the CircuitPython 2.x and 3.x library bundles. We highly encourage you to
update CircuitPython to the latest version (https://adafru.it/Em8) and use the current version of the
libraries (https://adafru.it/ENC). However, if for some reason you cannot update, you can find the last available 2.x
build here (https://adafru.it/FJA) and the last available 3.x build here (https://adafru.it/FJB).
CPLAYBOOT, TRINKETBOOT, FEATHERBOOT, or GEMMABOOT Drive Not
Present
You may have a different board.
Only Adafruit Express boards and the Trinket M0 and Gemma M0 boards ship with the UF2 bootloader
(https://adafru.it/zbX)installed. Feather M0 Basic, Feather M0 Adalogger, and similar boards use a regular Arduino-
compatible bootloader, which does not show a boardnameBOOT drive.
MakeCode
If you are running a MakeCode (https://adafru.it/zbY) program on Circuit Playground Express, press the reset button just
once to get the CPLAYBOOT drive to show up. Pressing it twice will not work.
Windows 10
Did you install the Adafruit Windows Drivers package by mistake? You don't need to install this package on Windows 10
for most Adafruit boards. The old version (v1.5) can interfere with recognizing your device. Go to Settings -> Apps and

uninstall all the "Adafruit" driver programs.
Windows 7
The latest version of the Adafruit Windows Drivers (version 2.0.0.0 or later) will fix the missing boardnameBOOT drive
problem on Windows 7. To resolve this, first uninstall the old versions of the drivers:
Unplug any boards. In Uninstall or Change a Program (Control Panel->Programs->Uninstall a program), uninstall
everything named "Windows Driver Package - Adafruit Industries LLC ...".
Now install the new 2.3.0.0 (or higher) Adafruit Windows Drivers Package:
https://adafru.it/AB0

When running the installer, you'll be shown a list of drivers to choose from. You can check and uncheck the
boxes to choose which drivers to install.
You should now be done! Test by unplugging and replugging the board. You should see the CIRCUITPY drive, and
when you double-click the reset button (single click on Circuit Playground Express running MakeCode), you should see
the appropriate boardnameBOOT drive.
Let us know in the Adafruit support forums (https://adafru.it/jIf) or on the Adafruit Discord () if this does not work for you!
Windows Explorer Locks Up When Accessing boardnameBOOT Drive
On Windows, several third-party programs we know of can cause issues. The symptom is that you try to access the
boardnameBOOT drive, and Windows or Windows Explorer seems to lock up. These programs are known to cause
trouble:
AIDA64: to fix, stop the program. This problem has been reported to AIDA64. They acquired hardware to test,
and released a beta version that fixes the problem. This may have been incorporated into the latest release.
Please let us know in the forums if you test thi.s
Hard Disk Sentinel
Kaspersky anti-virus: To fix, you may need to disable Kaspersky completely. Disabling some aspects of
Kaspersky does not always solve the problem. This problem has been reported to Kaspersky.
Copying UF2 to boardnameBOOT Drive Hangs at 0% Copied
On Windows, a Western DIgital (WD) utility that comes with their external USB drives can interfere with copying UF2
files to the boardnameBOOT drive. Uninstall that utility to fix the problem.
CIRCUITPY Drive Does Not Appear
Kaspersky anti-virus can block the appearance of the CIRCUITPY drive. We haven't yet figured out a settings change
that prevents this. Complete uninstallation of Kaspersky fixes the problem.
Norton anti-virus can interfere with CIRCUITPY . A user has reported this problem on Windows 7. The user turned off
both Smart Firewall and Auto Protect, and CIRCUITPY then appeared.
Serial Console in Mu Not Displaying Anything
There are times when the serial console will accurately not display anything, such as, when no code is currently
running, or when code with no serial output is already running before you open the console. However, if you find
yourself in a situation where you feel it should be displaying something like an error, consider the following.
Depending on the size of your screen or Mu window, when you open the serial console, the serial console panel may
be very small. This can be a problem. A basic CircuitPython error takes 10 lines to display!
Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.
code.py output:
Traceback (most recent call last):
File "code.py", line 7
SyntaxError: invalid syntax
Press any key to enter the REPL. Use CTRL-D to reload.
More complex errors take even more lines!
Therefore, if your serial console panel is five lines tall or less, you may only see blank lines or blank lines followed by
Press any key to enter the REPL. Use CTRL-D to reload.. If this is the case, you need to either mouse over the top of
the panel to utilise the option to resize the serial panel, or use the scrollbar on the right side to scroll up and find your
message.
This applies to any kind of serial output whether it be error messages or print statements. So before you start trying to
debug your problem on the hardware side, be sure to check that you haven't simply missed the serial messages due to
serial output panel height.
CircuitPython RGB Status Light
The Feather M0 Express, Feather M4 Express, Metro M0 Express, Metro M4 Express, ItsyBitsy M0 Express, ItsyBitsy M4
Express, Gemma M0, and Trinket M0 all have a single NeoPixel or DotStar RGB LED on the board that indicates the
status of CircuitPython.
Circuit Playground Express does NOT have a status LED. The LEDs will pulse green when in the bootloader. They do
NOT indicate any status while running CircuitPython.
Here's what the colors and blinking mean:
steady GREEN: code.py (or code.txt , main.py , or main.txt ) is running
pulsing GREEN: code.py (etc.) has finished or does not exist
steady YELLOW at start up: (4.0.0-alpha.5 and newer) CircuitPython is waiting for a reset to indicate that it should
start in safe mode
pulsing YELLOW: Circuit Python is in safe mode: it crashed and restarted
steady WHITE: REPL is running
steady BLUE: boot.py is running
Colors with multiple flashes following indicate a Python exception and then indicate the line number of the error. The
color of the first flash indicates the type of error:
GREEN: IndentationError
CYAN: SyntaxError
WHITE: NameError
ORANGE: OSError
PURPLE: ValueError
YELLOW: other error
These are followed by flashes indicating the line number, including place value. WHITE flashes are thousands' place,
BLUE are hundreds' place, YELLOW are tens' place, and CYAN are one's place. So for example, an error on line 32
would flash YELLOW three times and then CYAN two times. Zeroes are indicated by an extra-long dark gap.
ValueError: Incompatible .mpy file.
This error occurs when importing a module that is stored as a mpy binary file that was generated by a different
version of CircuitPython than the one its being loaded into. In particular, the mpy binary format changed between
CircuitPython versions 2.x and 3.x, as well as between 1.x and 2.x.
So, for instance, if you upgraded to CircuitPython 3.x from 2.x you’ll need to download a newer version of the library
that triggered the error on import . They are all available in the Adafruit bundle (https://adafru.it/y8E).
Make sure to download a version with 2.0.0 or higher in the filename if you're using CircuitPython version 2.2.4, and
the version with 3.0.0 or higher in the filename if you're using CircuitPython version 3.0.
CIRCUITPY Drive Issues
You may find that you can no longer save files to your CIRCUITPY drive. You may find that your CIRCUITPY stops
showing up in your file explorer, or shows up as NO_NAME . These are indicators that your filesystem has issues.
First check - have you used Arduino to program your board? If so, CircuitPython is no longer able to provide the USB
services. Reset the board so you get a boardnameBOOT drive rather than a CIRCUITPY drive, copy the latest version
of CircuitPython ( .uf2 ) back to the board, then Reset. This may restore CIRCUITPY functionality.
If still broken - When the CIRCUITPY disk is not safely ejected before being reset by the button or being disconnected
from USB, it may corrupt the flash drive. It can happen on Windows, Mac or Linux.
In this situation, the board must be completely erased and CircuitPython must be reloaded onto the board.
You WILL lose everything on the board when you complete the following steps. If possible, make a copy of
your code before continuing.
Easiest Way: Use storage.erase_filesystem()
Starting with version 2.3.0, CircuitPython includes a built-in function to erase and reformat the filesystem. If you have an
older version of CircuitPython on your board, you can update to the newest version (https://adafru.it/Amd) to do this.
1. Connect to the CircuitPython REPL (https://adafru.it/Bec) using Mu or a terminal program.
2. Type:
>>> import storage
>>> storage.erase_filesystem()
CIRCUITPY will be erased and reformatted, and your board will restart. That's it!
Old Way: For the Circuit Playground Express, Feather M0 Express, and Metro M0 Express:
If you can't get to the REPL, or you're running a version of CircuitPython before 2.3.0, and you don't want to upgrade,
you can do this.
1. Download the correct erase file:
https://adafru.it/AdI
https://adafru.it/AdI
https://adafru.it/AdJ
https://adafru.it/AdJ
https://adafru.it/EVK
https://adafru.it/EVK
https://adafru.it/AdK
https://adafru.it/AdK
https://adafru.it/EoM
https://adafru.it/EoM
https://adafru.it/DjD
https://adafru.it/DjD
https://adafru.it/DBA
https://adafru.it/DBA
https://adafru.it/Eca
https://adafru.it/Eca
https://adafru.it/Gnc
https://adafru.it/Gnc
https://adafru.it/GAN
https://adafru.it/GAN
https://adafru.it/GAO
https://adafru.it/GAO
2. Double-click the reset button on the board to bring up the boardnameBOOT drive.
3. Drag the erase .uf2 file to the boardnameBOOT drive.
4. The onboard NeoPixel will turn yellow or blue, indicating the erase has started.
5. After approximately 15 seconds, the mainboard NeoPixel will light up green. On the NeoTrellis M4 this is the first
NeoPixel on the grid
6. Double-click the reset button on the board to bring up the boardnameBOOT drive.
7. Drag the appropriate latest release of CircuitPython (https://adafru.it/Amd) .uf2 file to
the boardnameBOOT drive.
It should reboot automatically and you should see CIRCUITPY in your file explorer again.
If the LED flashes red during step 5, it means the erase has failed. Repeat the steps starting with 2.
If you haven't already downloaded the latest release of CircuitPython for your board, check out the installation
page (https://adafru.it/Amd). You'll also need to install your libraries and code!
Old Way: For Non-Express Boards with a UF2 bootloader (Gemma M0, Trinket M0):
If you can't get to the REPL, or you're running a version of CircuitPython before 2.3.0, and you don't want to upgrade,
you can do this.
1. Download the erase file:
https://adafru.it/AdL
https://adafru.it/AdL
Double-click the reset button on the board to bring up the boardnameBOOT drive.
Drag the erase .uf2 file to the boardnameBOOT drive.
The boot LED will start flashing again, and the boardnameBOOT drive will reappear.
Drag the appropriate latest release CircuitPython (https://adafru.it/Amd) .uf2 file to the boardnameBOOT drive.
It should reboot automatically and you should see CIRCUITPY in your file explorer again.
If you haven't already downloaded the latest release of CircuitPython for your board, check out the installation
page (https://adafru.it/Amd) You'll also need to install your libraries and code!
Old Way: For non-Express Boards without a UF2 bootloader (Feather M0 Basic Proto,
Feather Adalogger, Arduino Zero):
If you are running a version of CircuitPython before 2.3.0, and you don't want to upgrade, or you can't get to the REPL,
you can do this.
Just follow these directions to reload CircuitPython using bossac (https://adafru.it/Bed), which will erase and re-create
CIRCUITPY .
Running Out of File Space on Non-Express Boards
The file system on the board is very tiny. (Smaller than an ancient floppy disk.) So, its likely you'll run out of space but
don't panic! There are a couple ways to free up space.
The board ships with the Windows 7 serial driver too! Feel free to delete that if you don't need it or have already
installed it. Its ~12KiB or so.
Delete something!
The simplest way of freeing up space is to delete files from the drive. Perhaps there are libraries in the lib folder that
you aren't using anymore or test code that isn't in use. Don't delete the lib folder completely, though, just remove
what you don't need.
Use tabs
One unique feature of Python is that the indentation of code matters. Usually the recommendation is to indent code
with four spaces for every indent. In general, we recommend that too. However, one trick to storing more human-
readable code is to use a single tab character for indentation. This approach uses 1/4 of the space for indentation and
can be significant when we're counting bytes.
Mac OSX loves to add extra files.
Page 90 of 95Luckily you can disable some of the extra hidden files that Mac OSX adds by running a few commands to disable
search indexing and create zero byte placeholders. Follow the steps below to maximize the amount of space available
on OSX:
Prevent & Remove Mac OSX Hidden Files
First find the volume name for your board. With the board plugged in run this command in a terminal to list all the
volumes:
ls -l /Volumes
Look for a volume with a name like CIRCUITPY (the default for CircuitPython). The full path to the volume is
the /Volumes/CIRCUITPY path.
Now follow the steps from this question (https://adafru.it/u1c) to run these terminal commands that stop hidden files
from being created on the board:
mdutil -i off /Volumes/CIRCUITPY
cd /Volumes/CIRCUITPY
rm -rf .{,_.}{fseventsd,Spotlight-V*,Trashes}
mkdir .fseventsd
touch .fseventsd/no_log .metadata_never_index .Trashes
cd -
Replace /Volumes/CIRCUITPY in the commands above with the full path to your board's volume if it's different. At this
point all the hidden files should be cleared from the board and some hidden files will be prevented from being created.
However there are still some cases where hidden files will be created by Mac OSX. In particular if you copy a file that
was downloaded from the internet it will have special metadata that Mac OSX stores as a hidden file. Luckily you can
run a copy command from the terminal to copy files without this hidden metadata file. See the steps below.
Copy Files on Mac OSX Without Creating Hidden Files
Once you've disabled and removed hidden files with the above commands on Mac OSX you need to be careful to copy
files to the board with a special command that prevents future hidden files from being created. Unfortunately
you cannot use drag and drop copy in Finder because it will still create these hidden extended attribute files in some
cases (for files downloaded from the internet, like Adafruit's modules).
To copy a file or folder use the -X option for the cp command in a terminal. For example to copy a foo.mpy file to the
board use a command like:
Page 91 of 95cp -X foo.mpy /Volumes/CIRCUITPY
(Replace foo.mpy with the name of the file you want to copy.) Or to copy a folder and all of its child files/folders use a
command like:
cp -rX folder_to_copy /Volumes/CIRCUITPY
If you are copying to the lib folder, or another folder, make sure it exists before copying.
# if lib does not exist, you'll create a file named lib !
cp -X foo.mpy /Volumes/CIRCUITPY/lib
# This is safer, and will complain if a lib folder does not exist.
cp -X foo.mpy /Volumes/CIRCUITPY/lib/
Other Mac OSX Space-Saving Tips
If you'd like to see the amount of space used on the drive and manually delete hidden files here's how to do so. First
list the amount of space used on the CIRCUITPY drive with the df command:
Lets remove the ._ files first.

Whoa! We have 13Ki more than before! This space can now be used for libraries and code!

CircuitPython Essentials
You've gone through the Welcome to CircuitPython guide. You've already gotten everything setup, and you've gotten
CircuitPython running. Great! Now what? CircuitPython Essentials!
There are a number of core modules built into CircuitPython and commonly used libraries available. The Essentials
guide will introduce you to these and show you an example of how to use each one.
It's time to get started learning the CircuitPython Essentials (https://adafru.it/cpy-essentials)!

